# 理解 OC Block 的疑惑点

对于 iOS 开发者来说，Block 已经是一个老生常谈的话题的了，也已经有太多文章深入源码角度进行过详细的剖析, 本文仅用于记录一些之前令我个人疑惑的部分。

## Block 捕获外部变量的本质
无论是我们定义在 Class 中的方法还是 Block 中的代码，最终都会被编译成**顶层**函数，并写进二进制文件。 而这些编译之后的函数使用外部变量的方式只有两种： **被使用的变量本身就是全局的** 或者 **被使用的变量是函数参数**。

这两种方式在我们日常编写 Block 的时候都经常被用到。但除此之外，我们**还可以**捕获变量：在 Block 内部直接使用定义在外部的局部变量。因此这种底层没有的方式必须在编译时转换成底层支持的方式。将局部变量转换成全局的显然不合适，Block 采用的方式是转换成底层的函数的参数，来做到了对变量的捕获，这和 Class 的方法中可以直接访问 self 是类似的。

## 为什么copy到堆上
当我们最初初始化一个 Block 的时候，其内存是在函数的调用栈上, 是一个结构体，包含了：
- struct __block_impl impl;
- struct __main_block_desc_0* Desc；
- 其他被捕获的变量等

**栈上内存会在函数返回时被自动回收**，因此对于那些在函数返回之后，Block 被期望依旧能正常工作的场景，就需要将其从栈 copy到堆上，纳入ARC 的管理以防止被回收。
  
被当作参数传给其他的函数的 Block 也需要被 copy, 我觉得主要原因是 OC 并没有 Block 可逃逸的概念。用 Swift 的话说就是, OC 的 Block 都是可逃逸的，因此需要copy。

